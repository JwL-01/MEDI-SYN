# -*- coding: utf-8 -*-
"""gradio.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bVnncxq47IlBPvkXs5phBlvgoEkwpIw4
"""
import random
from torchvision import transforms

import torch
import torch.nn as nn
import matplotlib.pyplot as plt
import os
import gradio as gr
from PIL import Image
import numpy as np

from Diffusion.diffusion_model import StepwiseReverseDiffusionNet
from Diffusion.util_functs import reconstruct_image_iteratively
from label.label_model import StepwiseReverseDiffusionNet2

def load_and_get_stats(image_path):
    """
    Load an image and return its mean and standard deviation.

    Args:
        image_path (str): Path to the image file.

    Returns:
        tuple: Mean and standard deviation of the image.
    """
    img = Image.open(image_path).convert('L')  # Convert to grayscale if needed
    img_np = np.array(img)
    return img_np.mean(), img_np.std()

def normalize_image(img, target_mean, target_std):
    """
    Normalize an image to match the target mean and standard deviation.

    Args:
        img (numpy.ndarray): Image to be normalized.
        target_mean (float): Target mean.
        target_std (float): Target standard deviation.

    Returns:
        numpy.ndarray: Normalized image.
    """
    img_mean = img.mean()
    img_std = img.std()
    normalized_img = (img - img_mean) / img_std * target_std + target_mean
    return np.clip(normalized_img, 0, 255).astype(np.uint8)
sample_image_path = 'src/Diffusion/imaging/sample/sample_image.png'

sample_mean, sample_std = load_and_get_stats(sample_image_path)
def get_label_index(label):
    labels = ["glioma", "meningioma", "notumor", "pituitary"]
    try:
        return labels.index(label)
    except ValueError:
        return -1

# Function to be used in Gradio interface
def create_img(noise_level, label):

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    try:
        model = StepwiseReverseDiffusionNet().to(device)
        # Modify the torch.load function here to include map_location=torch.device('cpu')
        model.load_state_dict(torch.load('src/Diffusion/diffusion_model.pth', map_location=torch.device('cpu')))
        initial_noisy_image = torch.randn(1, 128, 128)
        denoised_image = reconstruct_image_iteratively(model, initial_noisy_image, 250)
        img = denoised_image.squeeze().detach().cpu().numpy()
        img_normalized = normalize_image(img, sample_mean, sample_std)
        data = Image.fromarray(img_normalized)

        model2 = StepwiseReverseDiffusionNet2(num_classes=4).to(device)
        model2.load_state_dict(torch.load('src/label/ddpm_label.pt', map_location=torch.device('cpu')))

        model2.eval()
        transform = transforms.Compose([
            transforms.Resize((128, 128)),  # Resize the image to the required input size of the model
            transforms.ToTensor(),          # Convert the image to a PyTorch tensor
        ])

        label_index = get_label_index(label)
        label_tensor = torch.tensor([label_index]).to(device)
        image_dir = 'src/label/sample_images'
        image_files = [f for f in os.listdir(image_dir) if os.path.isfile(os.path.join(image_dir, f))]
        selected_file = random.choice(image_files)
        image_path = os.path.join(image_dir, selected_file)
        selected_image = Image.open(image_path).convert('RGB')
        selected_image_tensor = transform(selected_image).unsqueeze(0)  # Add a batch dimension
        selected_image_tensor = selected_image_tensor.to(device)  # Move to the device

        # Use the tensor for model processing
        generated_image = model2(selected_image_tensor, label_tensor)
        generated_image = generated_image.squeeze(0).cpu().permute(1, 2, 0).detach().numpy()
        data2 = Image.fromarray((generated_image * 255).astype(np.uint8))

        return [data, data2]


        return [data, data2]

    except Exception as e:
        print("An error occurred: ", e)


# Create the Gradio interface
iface = gr.Interface(
    fn=create_img,
    inputs=[gr.Slider(minimum=0, maximum=100, step=1),
    gr.Radio(["glioma", "meningioma", "notumor", "pituitary"])],
    outputs=[gr.Image(shape=(300, 300)), gr.Image(shape=(300, 300))],
    title="DDPM & DDPM with label input",
    description="Creation of image might take up to 1 min. "
)

iface.launch(
    share=False,
    server_port=4000
)